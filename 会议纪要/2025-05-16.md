# 2025-5-16会议纪要

## 内容概述

1. 对比不同软件体系结构风格，明确本项目的适用风格。
2. 研究经典案例KWIC，分析其模块分解与风格选择。
3. 完善项目的软件体系结构文档（SAD），更新开发进度跟踪表。

## 会议内容

### 一、项目体系结构风格

本项目采用客户-服务器体系结构风格。客户端通过HTTP/HTTPS协议向服务器发起请求（如GET/POST），接收服务器返回的JSON/XML数据并动态渲染页面，通过Session维持用户状态（如登录态）。服务器负责接收客户端请求，验证权限，执行业务逻辑（如订单生成、数据分析），访问数据库读写数据，返回结构化数据。

在数据流与通信方面，本项目采用请求-响应模式，即客户端发起请求，服务器处理并返回响应，而且服务器不保存客户端上下文（除Session外），每次请求独立处理，所有数据存储在中心数据库，客户端无本地持久化。

### 二、KWIC

#### 1.KWIC系统简介

KWIC是一种经典的索引系统，由Parnas在1972年提出，用于研究软件模块化设计和体系结构风格。其核心功能包括：

（1）输入：接收若干行文本（每行由若干单词组成）。

（2）循环移位：对每行进行循环移位（如 "The sun rises" → "sun rises The" → "rises The sun"）。

（3）排序：按字母顺序排列所有移位后的行。

（4）输出：生成有序的索引列表。

#### 2.KWIC的体系结构风格对比

KWIC可以使用多种体系结构风格实现，每种风格在可修改性、复用性、性能等方面表现不同。

（1）主程序-子程序风格

架构特点：

- 系统分解为输入、移位、排序、输出四个子程序。
- 主程序按顺序调用子程序，数据通过共享存储区传递。

优点：

- 流程清晰，易于理解。
- 性能较高（数据直接共享）。

缺点：

- 数据表示变更困难，所有模块依赖存储格式。
- 复用性差，模块耦合度高。

（2） 面向对象风格

架构特点：

- 封装数据和行为，如 `Input`、`CircularShifter`、`Alphabetizer`、`Output` 类。
- 通过方法调用交互，避免直接数据共享。

优点：

- 数据表示变更灵活，封装降低影响范围。
- 支持复用，类可独立使用。

缺点：

- 功能扩展受限，新增功能需修改现有类或增加新类。

（3）管道-过滤器风格

架构特点：

- 系统分解为输入、移位、排序、输出四个过滤器。
- 数据通过管道流动，过滤器独立处理。

优点：

- 高可修改性，可插入新过滤器。
- 高复用性，过滤器可独立部署。

缺点：

- 性能较低，数据复制开销。
- 不适合交互式系统，无法支持动态删除行。

（3）事件驱动风格

架构特点：

- 数据变更触发事件（如 `LineStorage` 修改后自动调用 `CircularShifter`）。
- 计算模块隐式调用，而非显式控制。

优点：

- 易于扩展，新模块可注册事件。
- 数据与计算解耦。

缺点：

- 执行顺序难以控制。
- 空间占用高，事件队列管理。

### 三、各风格评分

##### **2.2.1主程序-子程序风格**

| **属性**         | **评分** | **说明**                                               |
| ---------------- | -------- | ------------------------------------------------------ |
| 易于改变算法     | 2        | 算法逻辑往往直接嵌入子程序中，修改需小心处理依赖关系。 |
| 易于改变数据表示 | 1        | 数据结构通常紧耦合在逻辑中，抽象程度低，改动代价大。   |
| 易于改变功能     | 3        | 功能变更需调整主流程，容易引发连锁修改，维护负担重。   |
| 好的性能         | 5        | 调用成本低，数据和流程紧凑，执行效率高。               |
| 有效的数据表示   | 4        | 使用原始数据结构简单高效，但缺乏弹性。                 |
| 易于复用         | 2        | 程序结构封闭，函数通用性差，复用能力弱。               |
| **总分**         | **52**   | 适合结构清晰、变动较少的简单程序。                     |

##### **2.2.2 面向对象风格**



| **属性**         | **评分** | **说明**                                               |
| ---------------- | -------- | ------------------------------------------------------ |
| 易于改变算法     | 3        | 算法可通过继承、接口或策略模式灵活更换，影响范围小。   |
| 易于改变数据表示 | 2        | 封装带来一定灵活性，但更改数据结构需同步修改相关方法。 |
| 易于改变功能     | 5        | 新增功能可通过增加类实现，旧代码无需修改，扩展性良好。 |
| 好的性能         | 4        | 对象创建和方法调用效率较高，性能基本可控。             |
| 有效的数据表示   | 1        | 类可灵活选择最合适的数据结构，支持面向抽象设计。       |
| 易于复用         | 4        | 类与接口之间的解耦设计，使得组件更易复用于其他场景。   |
| **总分**         | **61**   | 结构清晰，扩展性和维护性好，适用于大多数中型系统。     |

##### **2.2.3管道-过滤器风格**



| **属性**         | **评分** | **说明**                                                   |
| ---------------- | -------- | ---------------------------------------------------------- |
| 易于改变算法     | 1        | 每个过滤器独立处理功能，修改某一算法无需影响其他部分。     |
| 易于改变数据表示 | 5        | 数据以统一格式在过滤器间传递，各处理器可自由选择内部表示。 |
| 易于改变功能     | 4        | 添加或移除功能仅需插入或拆除过滤器模块，影响范围小。       |
| 好的性能         | 2        | 数据需在过滤器间频繁传输，序列化或转换可能造成开销。       |
| 有效的数据表示   | 3        | 支持逐步处理流式数据，但对内存和格式设计有一定要求。       |
| 易于复用         | 5        | 每个过滤器功能独立，接口统一，极易迁移到其他应用中使用。   |
| **总分**         | **73**   | 结构灵活，扩展自然，适用于数据处理与转换类系统。           |

##### **2.2.4事件驱动风格**



| **属性**         | **评分** | **说明**                                                     |
| ---------------- | -------- | ------------------------------------------------------------ |
| 易于改变算法     | 4        | 算法封装在事件处理器中，修改单个处理器较容易，但需维护事件流一致性。 |
| 易于改变数据表示 | 1        | 所有组件需共享事件格式，更改格式将波及多个模块。             |
| 易于改变功能     | 2        | 虽可动态添加事件类型，但需协调多个发布与订阅方，复杂度上升。 |
| 好的性能         | 3        | 异步机制可提升响应性，但处理链延迟和调试难度也随之增加。     |
| 有效的数据表示   | 5        | 事件数据格式通常为中间通用形式，便于传输但处理效率略低。     |
| 易于复用         | 3        | 模块依赖于事件总线协议，脱离原框架复用存在障碍。             |
| **总分**         | **53**   | 适合异步任务和用户交互频繁的系统，但不适合算法逻辑密集的场景如 KWIC。 |

##### **2.2.5微内核风格**



| **属性**         | **评分** | **说明**                                                 |
| ---------------- | -------- | -------------------------------------------------------- |
| 易于改变算法     | 5        | 插件中定义具体算法，实现与内核解耦，替换方便。           |
| 易于改变数据表示 | 4        | 内核只定义接口标准，插件可自由管理内部数据结构。         |
| 易于改变功能     | 3        | 新功能通过添加插件实现，内核保持稳定，演进性好。         |
| 好的性能         | 1        | 插件运行需额外模块管理与调用，性能略逊于直接调用。       |
| 有效的数据表示   | 2        | 插件可根据自身需求优化数据表示，但需适配内核协议。       |
| 易于复用         | 5        | 插件高度模块化，但需符合特定内核规范。                   |
| **总分**         | **64**   | 适用于需求复杂、可扩展性要求高的系统，如浏览器、IDE 等。 |

（评价的权重参考课本表5-3）

#### **2.3综合对比与推荐**

| 风格名称            | 总分   | 优点                           | 缺点                   |
| ------------------- | ------ | :----------------------------- | ---------------------- |
| 主程序-子程序       | 52     | 性能好、数据简单               | 改动困难、复用性差     |
| 面向对象风格        | 61     | 扩展性、复用性强               | 数据结构改动需同步多处 |
| **管道-过滤器风格** | **73** | **组件独立、功能组合灵活**     | 性能略差               |
| 事件驱动风格        | 53     | 异步灵活、适合松耦合架构       | 数据表示统一性要求高   |
| 微内核风格          | 64     | 插件化高扩展性、模块间隔离清晰 | 接口设计与通信复杂度高 |
