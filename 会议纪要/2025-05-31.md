
# 2025-5-31会议纪要

## 内容概述

结合项目的进程和开发历程，从设计原则的几个方面，组员对负责设计的模块进行评估，思考存在的问题和解决方案。

1. 结合项目的进程和开发历程，从设计原则的几个方面，组员对负责设计的模块进行评估，思考存在的问题和解决方案。
2. 查阅资料，学习依赖注入技术。
3. 论述利斯科夫替换原则（里氏代换原则）、单一职责原则、开闭原则、德（迪）米特法则、依赖倒转原则、合成复用原则，结合自己的实践项目举例说明如何应用 （保存到每个小组选定的协作开发平台上，以组为单位）。

## 会议内容

### 一、问题和解决方案

#### **1. 单一职责原则**

评估：
 部分模块在早期开发中承担了过多功能。例如用户管理模块最初集成了注册、登录、权限验证、日志记录等多个职责，导致代码复杂，后期维护困难。

问题：
 逻辑耦合严重，单一改动可能影响多个功能点。

改进方案：
 重构模块，提取日志处理与权限校验为独立服务，通过接口调用或中间件方式解耦，提升可读性与可维护性。

#### **2. 开放-封闭原则**

评估：
 图书展示与排序模块设计时未充分考虑扩展性，新增排序策略（如按评分、出版时间）需修改原始逻辑代码。

问题：
 功能变动直接触碰核心代码，违背“对扩展开放，对修改封闭”的原则。

改进方案：
 引入策略模式，将排序逻辑抽象为接口，具体策略通过注入或配置方式切换，提升灵活性和可扩展性。

#### **3. 依赖倒置原则**

评估：
 订单处理模块直接依赖具体的数据库实现（如MySQL语句嵌入逻辑层），不利于未来更换存储方案或测试。

问题：
 模块与底层实现强耦合，测试难度高，迁移成本大。

改进方案：
 重构为依赖接口而非具体实现，使用DAO层封装数据库操作，结合依赖注入提高灵活性与可测试性。

#### **4. 接口隔离原则（ISP）**

评估：
 初期设计的管理员接口过于庞大，不同角色（店主、系统维护员）共用同一接口，造成部分实现冗余或空方法。

问题：
 接口职责不清晰，使用者被迫依赖无关功能。

改进方案：
 重新拆分接口，根据角色细化接口职责，如`InventoryManager`、`UserAuditor`等，提高模块聚焦性。

#### **5. 低耦合高内聚**

评估：
 整体架构趋于模块化，但在数据传输上仍存在较多重复结构，尤其在图书模块与库存模块中存在数据冗余。

问题：
 结构重复、更新不一致导致维护负担加重。

改进方案：
 定义统一的数据模型DTO，避免结构重复，提高模块独立性与复用性。

### 二、依赖注入技术

#### 1.依赖注入概念

依赖注入是一种软件设计模式，它的核心目标是降低模块之间的耦合性，通过外部传入依赖对象而不是内部创建依赖，从而提升程序的可扩展性、可维护性、可测试性、模块解耦、支持运行时替换。

#### 2.为什么使用 DI

根据文档Dependency Injection-A Practical Introduction内容，总结 DI 的主要优点如下：

1. 可扩展性：新功能或模块可以在不修改现有代码的情况下进行添加。
2. 可测试性：可以轻松注入模拟或伪造依赖对象，用于单元测试。
3. 延迟绑定：程序可以在运行时替换不同实现，而无需重新编译。
4. 并行开发支持：各模块只依赖接口而非具体实现，方便多人协同开发。
5. 更强的维护性： 模块边界清晰，易于定位和修复问题。

####  3.DI 的实现方式（常见模式）

1. 构造函数注入
   最推荐的方式。依赖对象作为构造函数参数传入。
2. 属性注入
    通过公开属性注入依赖，适合可选依赖项。
3. 方法注入
    通过方法参数传入依赖对象，使用较少。
4. 服务定位器
    程序内部调用容器获取依赖，但会引入隐式依赖，不推荐。

### 三、论述各原则

在本次小组协作开发中，我们以“在线图书销售系统”为核心业务场景，针对项目中的模块设计，逐步引入了面向对象设计的六大原则，以下是各原则的定义、理解与在本项目中的具体应用示例。

#### 1. **里氏代换原则**

原则说明：

子类对象必须能够替换其父类对象，并保证程序行为的正确性。也就是说，使用父类的地方都可以透明地替换为子类，而不会引发错误或改变预期行为。

项目实践：

我们在实现“支付方式”模块时，定义了一个抽象类 `PaymentMethod`，其子类有 `CreditCardPayment`、`AlipayPayment`、`WeChatPayment` 等。所有子类都覆盖 `pay(amount)` 方法，调用方只依赖父类接口，无需关心具体子类。例如：

```java
public void processPayment(PaymentMethod method, double amount) {
    method.pay(amount);
}
```

通过符合里氏代换原则，我们可以在运行时自由替换支付方式，而无需修改调用方逻辑，增强了系统的扩展性和稳定性。

#### 2. **单一职责原则**

原则说明：

一个类应该仅有一个引起其变化的原因，即一个类只负责一项职责。

项目实践：

在“用户模块”初期，我们曾将用户注册、登录、密码找回、权限管理全部集中在 `UserManager` 类中，导致逻辑臃肿。重构后我们拆分成：

- `UserAuthService`：负责认证逻辑
- `UserRegisterService`：负责注册流程
- `UserPermissionService`：负责权限管理

每个类职责单一，便于后续功能扩展和独立测试，同时避免了因一个小改动影响整个系统的风险。

#### 3. **开闭原则**

原则说明：

软件实体（类、模块、函数等）应对扩展开放，对修改关闭。新增功能应通过扩展而非修改原有代码实现。

项目实践：

在实现“图书排序”功能时，我们没有在现有类中硬编码多个排序方式，而是定义接口 `BookSorter`，不同的排序策略实现该接口，如 `PriceSorter`、`TitleSorter`、`RatingSorter`。

```java
public interface BookSorter {
    List<Book> sort(List<Book> books);
}
```

在控制层中根据用户选择动态注入排序实现类，实现功能扩展而不需修改已有代码。

#### 4. **迪米特法则**

原则说明：

一个对象应尽量少地了解其他对象，尽量只与直接“朋友”通信，避免过深的依赖链和耦合。

项目实践：

在订单处理流程中，初期 `OrderService` 直接访问`User.getAccount().getCreditCard().getNumber()` 等嵌套调用，违反迪米特法则。后期我们通过提供中间方法 `User.getPaymentInfo()`，避免直接访问过深对象链，降低耦合，提高了模块独立性与可维护性。

#### 5. 依赖倒转原则

原则说明：

高层模块不应该依赖底层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。

项目实践：

在“库存模块”中，`InventoryService` 原本直接依赖 `MySQLInventoryRepository` 类，测试与扩展不方便。我们定义了接口 `InventoryRepository` 并让 `MySQLInventoryRepository` 实现它。

```java
public interface InventoryRepository {
    void updateStock(String bookId, int amount);
}
```

此后 `InventoryService` 只依赖接口，在实际运行中通过依赖注入容器注入实现类，实现了高层模块与低层模块解耦。

#### 6. **合成复用原则**

原则说明：

合成复用原则提倡使用对象组合（has-a）而不是类继承（is-a）来实现功能复用，从而降低类之间的耦合度，增强灵活性和可扩展性。

项目实践：

在“图书搜索”功能中，用户可以根据书名、作者、价格范围、出版年份等多个维度进行搜索。起初我们尝试为每种搜索条件创建一个继承自 `BaseSearchFilter` 的子类，如 `TitleSearchFilter`、`AuthorSearchFilter` 等，然后用继承链的方式逐步叠加条件。随着需求增加，组合查询变得困难，继承结构变得臃肿，不利于功能扩展。

于是我们采用对象组合方式重构了搜索逻辑。我们定义了统一接口 `SearchCriterion`，每种筛选条件都实现该接口，然后将多个筛选条件组合在一起，由一个 `CompositeSearch` 统一执行：

```java
public interface SearchCriterion {
    boolean matches(Book book);
}
public class CompositeSearch implements SearchCriterion {
    private List<SearchCriterion> criteria;

    public CompositeSearch(List<SearchCriterion> criteria) {
        this.criteria = criteria;
    }

    @Override
    public boolean matches(Book book) {
        return criteria.stream().allMatch(c -> c.matches(book));
    }
}
```

这种方式使得我们可以灵活组合任意多个筛选条件，比如“书名包含‘Python’且价格小于50元且出版年份在2020年之后”，而无需新增继承类或修改原有逻辑。组合方式不仅符合合成复用原则，也让模块更易扩展和测试。
