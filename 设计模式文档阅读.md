阅读总结文档内容。

## 一、设计模式

设计模式是针对在面向对象软件开发中反复出现的问题的一种通用解决方案模板。它们描述了对象之间的交互关系，帮助开发者编写更灵活、可复用和可维护的系统。

定义（GoF）： “每一个模式描述了一个不断重复出现的问题以及问题的核心解决方案，以便你可以重复使用这个解决方案。”

## 二、设计模式的四个基本要素：

1. 名称：简洁表述模式本质，形成设计语言。
2. 问题：说明模式适用的情景、背景。
3. 解决方案：设计结构的抽象描述，不局限于具体实现。
4. 效果：权衡、优缺点、灵活性、可扩展性、效率等。

## 三、设计模式的三大类：

### 1. 创建型

关注对象的创建过程。

- **Abstract Factory**：提供一个创建相关或依赖对象的接口，而无须指定具体类。
- **Builder**：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
- **Factory Method**：定义一个创建对象的接口，让子类决定实例化哪一个类。
- **Prototype**：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新对象。
- **Singleton**：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### 2. 结构型

关注类和对象的组合。

- **Adapter**：将一个类的接口转换成客户希望的另一个接口。
- **Bridge**：将抽象部分与实现部分分离，使它们都可以独立地变化。
- **Composite**：将对象组合成树形结构表示“部分-整体”的层次结构。
- **Decorator**：动态地给一个对象添加一些额外的职责。
- **Facade**：为子系统中的一组接口提供一个统一的高层接口。
- **Flyweight**：运用共享技术有效支持大量细粒度对象。
- **Proxy**：为其他对象提供一种代理以控制对这个对象的访问。

### 3. 行为型

关注对象之间的职责分配与协作。

- **Chain of Responsibility**：使多个对象有机会处理请求，避免请求发送者与接收者之间的耦合。
- **Command**：将请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。
- **Interpreter**：为语言创建解释器类，解释语言的文法。
- **Iterator**：顺序访问聚合对象的元素，而不暴露其内部表示。
- **Mediator**：用一个中介对象封装一系列对象交互。
- **Memento**：在不破坏封装性的前提下，捕获并恢复对象的内部状态。
- **Observer**：当一个对象状态改变时，自动通知所有依赖于它的对象。
- **State**：允许对象在内部状态改变时改变它的行为。
- **Strategy**：定义一系列算法，将每一个算法封装起来，使它们可以互换。
- **Template Method**：定义一个操作中的算法框架，将一些步骤延迟到子类中。
- **Visitor**：表示一个作用于某对象结构中的各元素的操作。

## 四、设计模式的使用方式

- 查找问题 → 匹配模式 → 应用结构
- 根据“意图”或“适用性”定位合适模式
- 组合使用多个模式（如组合+迭代器+访问者）
- 根据“目的”+“作用范围”分类查找合适的模式

## 五、设计模式的价值

- 提高代码复用性与可维护性
- 降低系统耦合度，增强扩展性
- 提升团队沟通效率（通过命名和结构共享共识）
- 系统化面向对象经验总结